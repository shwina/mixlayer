#!/bin env python
import sys

from attrdict import AttrDict
import yaml

import numpy as np
import h5py
from numba import jit, float64, prange

from mixlayer.derivatives import BoundaryType
from mixlayer.grid.mapped import SinhGrid
from mixlayer.timestepping import RK4
from mixlayer.filtering import filter5
from mixlayer.models.eos import IdealGasEOS
from mixlayer.poisson import PoissonSolver

def add_forcing(p, g):

    fx = np.zeros_like(g.x, dtype=np.float64)
    fy = np.zeros_like(g.x, dtype=np.float64)
    fx_max = 0

    vort = np.zeros_like(g.x, dtype=np.float64)
    stream = np.zeros([p.N, p.N], dtype=np.float64)

    amplitudes = [1, 0.5, 0.35, 0.35]
    for i in range(4):
        fx += amplitudes[i]*np.abs(np.sin(np.pi*g.x/(2**i*p.disturbance_wavelength)))
        fx_max = np.max([np.max(fx), fx_max])
    
    fx = fx/fx_max
    fy = np.exp(-np.pi*g.y**2/p.vorticity_thickness**2)
    
    vort[...] = fx*fy
    circ = np.sum(g.dy*g.dx*vort)

    vort[...] = (vort*p.Famp_2d*p.disturbance_wavelength*p.U_ref) / (circ/p.nperiod)

    ps = PoissonSolver(p.N, g.dx, g.dy)
    ps.solve(-vort, stream)

    u_pert = (np.roll(stream, -1, 1) - np.roll(stream, 1, 1))/(2*g.dy)
    v_pert = -(np.roll(stream, -1, 0) - np.roll(stream, 1, 0))/(2*g.dx)

    vort[...] = ((np.roll(stream, -1, 1) - 2*stream + np.roll(stream, 1, 1))/(g.dx**2) +
                 (np.roll(stream, -1, 0) - 2*stream + np.roll(stream, 1, 0))/(g.dy**2))

    circ = np.sum(g.dy*g.dx*vort)

    u_pert = u_pert*p.Famp_2d*p.disturbance_wavelength*p.U_ref / (circ/p.nperiod)
    v_pert = v_pert*p.Famp_2d*p.disturbance_wavelength*p.U_ref / (circ/p.nperiod)

    return u_pert, v_pert

def calculate_timestep(p, g, eos):

    tmp[...] = (egy -
            0.5*(rho_u**2 + rho_v**2)/rho
        ) / (rho*eos.Cv)

    eos.pressure(tmp, rho, prs)

    dxmin = np.minimum(g.dx, g.dy)

    # calculate diffusivities:
    alpha_1 = p.gamma_ref
    alpha_2 = p.mu_ref/rho
    alpha_3 = p.kappa_ref/(eos.Cp*rho)
    alpha_max = np.maximum(np.maximum(alpha_1, alpha_2), alpha_3)

    # calculate C_sound
    C_sound = np.sqrt(eos.Cp/eos.Cv*eos.R*tmp)
    test_1 = p.cfl_vel*g.dx/(C_sound + abs(rho_u/rho))
    test_2 = p.cfl_vel*g.dy/(C_sound + abs(rho_v/rho))
    test_3 = p.cfl_visc*(dxmin**2)/alpha_max

    dt = np.min(np.minimum(np.minimum(test_1, test_2), test_3))
    return dt

def apply_filter(p, f):
    for f in rho, rho_u, rho_v, egy:
        filter5(f)

def non_reflecting_boundary_conditions(p, g, eos, rhs):

    rho_rhs = rhs[0, ...]
    rho_u_rhs = rhs[1, ...]
    rho_v_rhs = rhs[2, ...]
    egy_rhs = rhs[3, ...]

    C_sound = np.sqrt(eos.Cp/eos.Cv * eos.R*tmp)

    dpdy = g.dfdy(prs)
    drhody = g.dfdy(rho)
    dudy = g.dfdy(rho_u/rho)
    dvdy = g.dfdy(rho_v/rho)
    
    L_1 = (rho_v/rho - C_sound) * (dpdy - rho*C_sound*dvdy)
    L_2 = rho_v/rho * (C_sound**2 * drhody - dpdy)
    L_3 = rho_v/rho * dudy
    L_4 = 0.4*(1 - p.Ma**2) * C_sound/p.Ly * (prs - p.P_inf)

    d_1 = (1. / C_sound**2) * (L_2 + 0.5*(L_4 + L_1))
    d_2 = 0.5*(L_1 + L_4)
    d_3 = L_3
    d_4 = 1./(2*rho*C_sound) * (L_4 - L_1)

    rho_rhs[0, :] = (rho_rhs - d_1)[0, :]
    rho_u_rhs[0, :] = (rho_u_rhs - rho_u/rho*d_1 - rho*d_3)[0, :]
    rho_v_rhs[0, :] = (rho_v_rhs - rho_v/rho*d_1 - rho*d_4)[0, :]
    egy_rhs[0, :] = (egy_rhs -
        0.5*np.sqrt((rho_u/rho)**2 + (rho_v/rho)**2)*d_1 -
        d_2 * (prs + egy) / (rho*C_sound**2) -
        rho * (rho_v/rho * d_4 + rho_u/rho * d_3))[0, :]

    L_1 = 0.4 * (1 - p.Ma**2) * C_sound/p.Ly * (prs - p.P_inf)
    L_2 = rho_v/rho * (C_sound**2 * drhody - dpdy)
    L_3 = rho_v/rho * dudy
    L_4 = (rho_v/rho + C_sound) * (dpdy + rho*C_sound*dvdy)

    d_1 = (1./C_sound**2) * (L_2 + 0.5*(L_4 + L_1))
    d_2 = 0.5*(L_1 + L_4)
    d_3 = L_3
    d_4 = 1/(2*rho*C_sound) * (L_4 - L_1)

    rho_rhs[-1, :] = (rho_rhs - d_1)[-1, :]
    rho_u_rhs[-1, :] = (rho_u_rhs - rho_u/rho*d_1 - rho*d_3)[-1, :]
    rho_v_rhs[-1, :] = (rho_v_rhs - rho_v/rho*d_1 - rho*d_4)[-1, :]
    egy_rhs[-1, :] = (egy_rhs-
        0.5*np.sqrt((rho_u/rho)**2 + (rho_v/rho)**2)*d_1 -
        d_2 * (prs + egy) / (rho*C_sound**2) -
        rho * (rho_v/rho * d_4 + rho_u/rho * d_3))[-1, :]

def update_temperature_and_pressure(eos):
    tmp[...] = (egy - 0.5*(rho_u**2 + rho_v**2)/rho) / (rho*eos.Cv)
    eos.pressure(tmp, rho, prs)

def rhs(p, g, eos, out=None):
    
    update_temperature_and_pressure(eos)

    rho_rhs = out[0, ...]
    rho_u_rhs = out[1, ...]
    rho_v_rhs = out[2, ...]
    egy_rhs = out[3, ...]

    # euler terms:
    rho_rhs[...] = -g.dfdy(rho_v)
    rho_rhs[[0,-1], :] = 0
    rho_rhs[...] += -g.dfdx(rho_u)

    rho_u_rhs[...] = -g.dfdy(rho_u * rho_v/rho)
    rho_u_rhs[[0,-1], :] = 0
    rho_u_rhs += -g.dfdx(rho_u*rho_u/rho + prs) 
    
    rho_v_rhs[...] = -g.dfdy(rho_v*rho_v/rho + prs)
    rho_v_rhs[[0,-1], :] = 0 
    rho_v_rhs += -g.dfdx(rho_v*rho_u/rho )
    
    egy_rhs_x = -g.dfdx((egy + prs)*(rho_u/rho))
    egy_rhs_y = -g.dfdy((egy + prs)*(rho_v/rho))
    egy_rhs_y[[0,-1], :] = 0

    egy_rhs[...] = egy_rhs_x + egy_rhs_y

    # viscous terms:
    div_vel = g.dfdx(rho_u / rho) + g.dfdy(rho_v / rho)

    tau_11 = -(2./3)*p.mu_ref*div_vel + 2*p.mu_ref*g.dfdx(rho_u / rho) 
    tau_22 = -(2./3)*p.mu_ref*div_vel + 2*p.mu_ref*g.dfdy(rho_v / rho)
    tau_12 = p.mu_ref*(g.dfdx(rho_v / rho) + g.dfdy(rho_u / rho))
    
    tau_12[0, :] = (18.*tau_12[1, :] - 9*tau_12[2, :] + 2*tau_12[3, :]) / 11
    tau_12[-1, :] = (18.*tau_12[-2, :] - 9*tau_12[-3, :] + 2*tau_12[-4, :]) / 11

    rho_u_rhs += g.dfdx(tau_11) + g.dfdy(tau_12)
    rho_v_rhs += g.dfdx(tau_12) + g.dfdy(tau_22)
    egy_rhs += (g.dfdx(rho_u/rho * tau_11) +
                  g.dfdx(rho_v/rho * tau_12) +
                  g.dfdy(rho_u/rho * tau_12) +
                  g.dfdy(rho_v/rho * tau_22) + 
                  p.kappa_ref*(
                    g.dfdx(g.dfdx(tmp)) +
                    g.dfdy(g.dfdy(tmp))))

    non_reflecting_boundary_conditions(p, g, eos, out)




paramfile = sys.argv[1]

p = AttrDict()

with open(paramfile) as f:
    p.update(yaml.load(f))

p.Ly = p.Lx*((p.N-1)/p.N)*2.

# reference temperature
p.T_ref = max([p.T_inf2, 344.6])

# eos parameters
p.Rspecific = 287

# reference density
p.rho_ref1 = p.P_inf/(p.Rspecific*p.T_inf1)
p.rho_ref2 = p.P_inf/(p.Rspecific*p.T_inf2)
p.rho_ref = (p.rho_ref1+p.rho_ref2)/2.0

# reference velocities 
p.C_sound1 = np.sqrt((p.Cp/p.Cv)*(p.Rspecific)*p.T_inf1)
p.C_sound2 = np.sqrt((p.Cp/p.Cv)*(p.Rspecific)*p.T_inf2)
p.U_inf1 = 2*p.Ma*p.C_sound1/(1+np.sqrt(p.rho_ref1/p.rho_ref2)*(p.C_sound1/p.C_sound2))
p.U_inf2 = -np.sqrt(p.rho_ref1/p.rho_ref2)*p.U_inf1
p.U_ref = p.U_inf1-p.U_inf2

# grid parameters
p.dx = p.Lx/p.N
p.dn = 1./(p.N-1)

# geometric parameters
p.disturbance_wavelength = p.Lx/p.nperiod
p.vorticity_thickness = p.disturbance_wavelength/7.29

# reference viscosity; thermal and molecular diffusivities
p.rho_ref = (p.rho_ref1+p.rho_ref2)/2.0
p.mu_ref = (p.rho_ref*(p.U_inf1-p.U_inf2)*p.vorticity_thickness)/p.Re
p.kappa_ref = 0.5*(p.Cp+p.Cp)*p.mu_ref/p.Pr 
p.gamma_ref = p.mu_ref/(p.rho_ref*p.Pr)

# fields
dims = [p.N, p.N]
U = np.zeros([4, p.N, p.N], dtype=np.float64)
rho = U[0, ...]
rho_u = U[1, ...]
rho_v = U[2, ...]
egy = U[3, ...]
tmp = np.zeros(dims, dtype=np.float64)
prs = np.zeros(dims, dtype=np.float64)
stream = np.zeros(dims, dtype=np.float64)
vort = np.zeros(dims, dtype=np.float64)

# make grid
g = SinhGrid(p.N, p.N, p.Lx, p.Ly, p.grid_beta, BoundaryType.PERIODIC, BoundaryType.INNER)

# initialize fields
weight = np.tanh(np.sqrt(np.pi)*g.y/p.vorticity_thickness)

tmp[:, :] = p.T_inf2 + (weight+1)/2.*(p.T_inf1-p.T_inf2)
rho[:, :] = p.P_inf/(p.Rspecific*tmp[:, :])

rho_u[:, :] = rho*(p.U_inf2+(weight+1)/2.*(p.U_inf1-p.U_inf2))
rho_v[:, :] = 0.0

u_pert, v_pert = add_forcing(p, g)

rho_u += rho*u_pert
rho_v += rho*v_pert

egy[:, :] = 0.5*(rho_u**2 + rho_v**2)/rho + rho*p.Cv*tmp

eos = IdealGasEOS()

# make time stepper
stepper = RK4(U, rhs, p, g, eos)

# run simulation
import timeit

for i in range(p.timesteps):
    
    dt = calculate_timestep(p, g, eos)

    print("Iteration: {:10d}    Time: {:15.10e}    Total energy: {:15.10e}".format(i, dt*i, np.sum(egy)))

    stepper.step(dt)
    apply_filter(p, f)

    if p.writer:
        if i%200 == 0:
            outfile = h5py.File("{:05d}.hdf5".format(i))
            outfile.create_group("fields")
            outfile.create_dataset("fields/rho", data=rho)
            outfile.create_dataset("fields/rho_u", data=rho_u)
            outfile.create_dataset("fields/rho_v", data=rho_v)
            outfile.create_dataset("fields/tmp", data=tmp)

